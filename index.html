
<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>fluuu.id</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="/css/site.css">
    </head>
    <body>
        <script src="/js/v.js"></script>
        <script src="/js/wagner/Wagner.js"></script>
        <script src="/js/wagner/Wagner.base.js"></script>
        <script src="/js/wagner/ShaderLoader.js"></script>
        <script id="shader-vertex-terrain" type="x-shader/x-vertex">

            //
            // GLSL textureless classic 3D noise "cnoise",
            // with an RSL-style periodic variant "pnoise".
            // Author:  Stefan Gustavson (stefan.gustavson@liu.se)
            // Version: 2011-10-11
            //
            // Many thanks to Ian McEwan of Ashima Arts for the
            // ideas for permutation and gradient selection.
            //
            // Copyright (c) 2011 Stefan Gustavson. All rights reserved.
            // Distributed under the MIT license. See LICENSE file.
            // https://github.com/ashima/webgl-noise
            //

            vec3 mod289(vec3 x)
            {
              return x - floor(x * (1.0 / 289.0)) * 289.0;
            }

            vec4 mod289(vec4 x)
            {
              return x - floor(x * (1.0 / 289.0)) * 289.0;
            }

            vec4 permute(vec4 x)
            {
              return mod289(((x*34.0)+1.0)*x);
            }

            vec4 taylorInvSqrt(vec4 r)
            {
              return 1.79284291400159 - 0.85373472095314 * r;
            }

            vec3 fade(vec3 t) {
              return t*t*t*(t*(t*6.0-15.0)+10.0);
            }

            // Classic Perlin noise
            float cnoise(vec3 P)
            {
              vec3 Pi0 = floor(P); // Integer part for indexing
              vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
              Pi0 = mod289(Pi0);
              Pi1 = mod289(Pi1);
              vec3 Pf0 = fract(P); // Fractional part for interpolation
              vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
              vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
              vec4 iy = vec4(Pi0.yy, Pi1.yy);
              vec4 iz0 = Pi0.zzzz;
              vec4 iz1 = Pi1.zzzz;

              vec4 ixy = permute(permute(ix) + iy);
              vec4 ixy0 = permute(ixy + iz0);
              vec4 ixy1 = permute(ixy + iz1);

              vec4 gx0 = ixy0 * (1.0 / 7.0);
              vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
              gx0 = fract(gx0);
              vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
              vec4 sz0 = step(gz0, vec4(0.0));
              gx0 -= sz0 * (step(0.0, gx0) - 0.5);
              gy0 -= sz0 * (step(0.0, gy0) - 0.5);

              vec4 gx1 = ixy1 * (1.0 / 7.0);
              vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
              gx1 = fract(gx1);
              vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
              vec4 sz1 = step(gz1, vec4(0.0));
              gx1 -= sz1 * (step(0.0, gx1) - 0.5);
              gy1 -= sz1 * (step(0.0, gy1) - 0.5);

              vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
              vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
              vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
              vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
              vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
              vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
              vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
              vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

              vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
              g000 *= norm0.x;
              g010 *= norm0.y;
              g100 *= norm0.z;
              g110 *= norm0.w;
              vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
              g001 *= norm1.x;
              g011 *= norm1.y;
              g101 *= norm1.z;
              g111 *= norm1.w;

              float n000 = dot(g000, Pf0);
              float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
              float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
              float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
              float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
              float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
              float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
              float n111 = dot(g111, Pf1);

              vec3 fade_xyz = fade(Pf0);
              vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
              vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
              float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
              return 2.2 * n_xyz;
            }

            // Classic Perlin noise, periodic variant
            float pnoise(vec3 P, vec3 rep)
            {
              vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
              vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
              Pi0 = mod289(Pi0);
              Pi1 = mod289(Pi1);
              vec3 Pf0 = fract(P); // Fractional part for interpolation
              vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
              vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
              vec4 iy = vec4(Pi0.yy, Pi1.yy);
              vec4 iz0 = Pi0.zzzz;
              vec4 iz1 = Pi1.zzzz;

              vec4 ixy = permute(permute(ix) + iy);
              vec4 ixy0 = permute(ixy + iz0);
              vec4 ixy1 = permute(ixy + iz1);

              vec4 gx0 = ixy0 * (1.0 / 7.0);
              vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
              gx0 = fract(gx0);
              vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
              vec4 sz0 = step(gz0, vec4(0.0));
              gx0 -= sz0 * (step(0.0, gx0) - 0.5);
              gy0 -= sz0 * (step(0.0, gy0) - 0.5);

              vec4 gx1 = ixy1 * (1.0 / 7.0);
              vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
              gx1 = fract(gx1);
              vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
              vec4 sz1 = step(gz1, vec4(0.0));
              gx1 -= sz1 * (step(0.0, gx1) - 0.5);
              gy1 -= sz1 * (step(0.0, gy1) - 0.5);

              vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
              vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
              vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
              vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
              vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
              vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
              vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
              vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

              vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
              g000 *= norm0.x;
              g010 *= norm0.y;
              g100 *= norm0.z;
              g110 *= norm0.w;
              vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
              g001 *= norm1.x;
              g011 *= norm1.y;
              g101 *= norm1.z;
              g111 *= norm1.w;

              float n000 = dot(g000, Pf0);
              float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
              float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
              float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
              float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
              float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
              float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
              float n111 = dot(g111, Pf1);

              vec3 fade_xyz = fade(Pf0);
              vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
              vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
              float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
              return 2.2 * n_xyz;
            }

            varying vec2  v_uv;
            varying vec3  v_line_color;
            varying float noise;

            uniform float time;
            uniform float speed;
            uniform float valley_elevation;
            uniform float noise_elevation;

            #define M_PI 3.1415926535897932384626433832795

            void main()
            {
                gl_PointSize = 4.;
                v_uv          = uv;

                // First perlin passes
                float displacement  = pnoise( .4 * position + vec3( 0, speed * time, 0 ), vec3( 100.0 ) ) * 1. * noise_elevation;
                displacement       += pnoise( 2. * position + vec3( 0, speed * time * 5., 0 ), vec3( 100. ) ) * .3 * noise_elevation;
                displacement       += pnoise( 8. * position + vec3( 0, speed * time * 20., 0 ), vec3( 100. ) ) * .1 * noise_elevation;

                // Sinus
                displacement = displacement + (sin(position.x / 2. - M_PI / 2.)) * valley_elevation;

                vec3 newPosition = vec3(position.x,position.y,displacement);
                gl_Position      = projectionMatrix * modelViewMatrix * vec4( newPosition, 1. );
            }

    </script>

    <script id="shader-fragment-terrain" type="x-shader/x-fragment">

        varying vec2 v_uv;
        varying vec3 v_line_color;
        uniform float time;

        #define M_PI 3.1415926535897932384626433832795

        void main()
        {
            float alpha = sin(v_uv.y * M_PI) / 8.;

            float time2 = time / 8.;

            float r = sin(time2);
            float g = sin(time2/2.);
            float b = sin(time2);

            gl_FragColor = vec4(r, g, b, alpha);
        }

    </script>

        <script>
            var scene, camera, renderer, controls;

            var plane_material, composer;

            var options =
            {
                valley_elevation : .5,
                noise_elevation  : .5,
                speed            : 0.4
            }

            var uniforms = {
                time :
                {
                    type  : 'f',
                    value : 0.0
                },
                speed :
                {
                    type  : 'f',
                    value : options.speed
                },
                valley_elevation :
                {
                    type  : 'f',
                    value : options.valley_elevation
                },
                noise_elevation :
                {
                    type  : 'f',
                    value : options.noise_elevation
                },
                offset :
                {
                    type  : 'f',
                    value : options.valley_elevation
                }
            };

            var clock;

            WAGNER.vertexShadersPath = "/shaders/vertex-shaders";
            WAGNER.fragmentShadersPath = "/shaders/fragment-shaders";
            WAGNER.assetsPath = "/shaders/assets/";

            var dirtPass, 
                barrelBlurPass,
                invertPass,
                boxBlurPass,
                fullBoxBlurPass,
                zoomBlurPass,
                multiPassBloomPass,
                denoisePass,
                sepiaPass,
                noisePass,
                vignettePass,
                vignette2Pass,
                CGAPass,
                edgeDetectionPass,
                dirtPass,
                blendPass,
                guidedFullBoxBlurPass,
                SSAOPass;

            buildScene();
            initPass();
            update();

            function initPass(){
                composer = new WAGNER.Composer( renderer, { useRGBA: false } );
                composer.setSize( window.innerWidth, window.innerHeight );

                // invertPass = new WAGNER.InvertPass();
                 // boxBlurPass = new WAGNER.BoxBlurPass();
                // fullBoxBlurPass = new WAGNER.FullBoxBlurPass();
                // zoomBlurPass = new WAGNER.ZoomBlurPass();
                 multiPassBloomPass = new WAGNER.MultiPassBloomPass();
                denoisePass = new WAGNER.DenoisePass();
                // sepiaPass = new WAGNER.SepiaPass();
                // noisePass = new WAGNER.NoisePass();
                vignettePass = new WAGNER.VignettePass();
                // vignette2Pass = new WAGNER.Vignette2Pass();
                // CGAPass = new WAGNER.CGAPass();
                // edgeDetectionPass = new WAGNER.EdgeDetectionPass();
                dirtPass = new WAGNER.DirtPass();
                blendPass = new WAGNER.BlendPass();
                // guidedFullBoxBlurPass = new WAGNER.GuidedFullBoxBlurPass();
                // SSAOPass = new WAGNER.SSAOPass();
            }

            function renderPass() {
                composer.reset();
                composer.render( scene, camera );
                
                composer.pass( multiPassBloomPass );
                composer.pass( blendPass );
                composer.pass( dirtPass ) ;
                composer.pass( vignettePass );

                composer.toScreen();
            }

            function buildScene() {
                scene = new THREE.Scene();
                //camera = new THREE.OrthographicCamera(window.innerWidth * -0.5, window.innerWidth * 0.5, window.innerHeight * 0.5, window.innerHeight * -0.5, .1, 10000);
                camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 10000 );
                camera.position.z = 7;
                camera.lookAt(0);
                scene.add( camera );

                clock = new THREE.Clock( false );

                plane_geometry = new THREE.PlaneGeometry(10,10,200,200);
                plane_material = new THREE.ShaderMaterial({
                    vertexShader       : document.getElementById("shader-vertex-terrain").textContent,
                    fragmentShader     : document.getElementById("shader-fragment-terrain").textContent,
                    wireframe          : false,
                    wireframeLinewidth : 1,
                    transparent        : true,
                    uniforms           : uniforms
                });

                plane_mesh = new THREE.Mesh(plane_geometry,plane_material);
                plane_mesh.rotation.x = - Math.PI / 2;
                plane_mesh.position.y = -0.5;
                scene.add(plane_mesh);

                renderer = new THREE.WebGLRenderer({antialias: false, alpha: false});
                renderer.autoClearColor = true
                document.body.appendChild( renderer.domElement );
                renderer.setSize( window.innerWidth, window.innerHeight);

                clock.start();

                addControls();
            };

            function addControls()
            {
                controls = new THREE.OrbitControls( camera );
                controls.enabled = false;
                controls.addEventListener( 'change', render );
                window.addEventListener("resize", onWindowResize);

                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                stats.domElement.style.display = 'none';
                document.body.appendChild(stats.domElement);
            }

            function update() {
                
                requestAnimationFrame(update);
                controls.update();

                plane_material.uniforms['time'].value = clock.getElapsedTime();
                render()
            };

            function render() {
                //renderer.render( scene, camera );
                renderPass();
                stats.update();
            }

            //EVENTS
            function onWindowResize() {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.left = -window.innerWidth * 0.5;
                camera.right = window.innerWidth * 0.5;
                camera.top = window.innerHeight * 0.5;
                camera.bottom = -window.innerHeight * 0.5;
                camera.updateProjectionMatrix();
            };
        </script>

        <div id="wrapper">
            <div class="table">
                <div class="row">
                    <div class="cell">
                        <img src="/img/fluuuid.svg" alt="FLUUUID">
                        <p><a href="mailto:heeey@fluuu.id">heeey@fluuu.id</a></p>
                    </div>
                </div>
            </div>
        </div>
    </body>
</html>
